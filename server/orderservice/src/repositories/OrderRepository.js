const Order = require('../models/Order');

/**
 * OrderRepository - Handles all database operations for orders
 * Following SOLID principles: Single Responsibility & Dependency Inversion
 */
class OrderRepository {
  constructor(orderModel = Order) {
    this.Order = orderModel;
  }

  /**
   * Save a new order to the database
   * @param {Object} orderData - Order data to save
   * @returns {Promise<Object>} Saved order
   */
  async save(orderData) {
    try {
      const order = new this.Order(orderData);
      
      // Basic validation before save (orderId will be generated by pre-save middleware)
      const validationErrors = order.validateOrder();
      
      if (validationErrors.length > 0) {
        throw new Error(`Validation failed: ${validationErrors.join(', ')}`);
      }
      
      // Save will trigger pre-save middleware to generate orderId and calculate totalAmount
      return await order.save();
    } catch (error) {
      throw new Error(`Failed to save order: ${error.message}`);
    }
  }

  /**
   * Find order by ID
   * @param {String} orderId - Order ID to search
   * @returns {Promise<Object|null>} Found order or null
   */
  async findById(orderId) {
    try {
      return await this.Order.findOne({ orderId });
    } catch (error) {
      throw new Error(`Failed to find order by ID: ${error.message}`);
    }
  }

  /**
   * Find all orders for a customer
   * @param {String} customerId - Customer ID
   * @param {Object} options - Query options (limit, skip, sort)
   * @returns {Promise<Array>} Array of orders
   */
  async findByCustomerId(customerId, options = {}) {
    try {
      const { limit = 10, skip = 0, sort = { createdAt: -1 } } = options;
      
      return await this.Order
        .find({ customerId })
        .sort(sort)
        .limit(limit)
        .skip(skip);
    } catch (error) {
      throw new Error(`Failed to find orders for customer: ${error.message}`);
    }
  }

  /**
   * Update order status
   * @param {String} orderId - Order ID
   * @param {String} newStatus - New status
   * @returns {Promise<Object|null>} Updated order
   */
  async updateStatus(orderId, newStatus) {
    try {
      const order = await this.Order.findOne({ orderId });
      
      if (!order) {
        return null;
      }

      order.status = newStatus;
      return await order.save();
    } catch (error) {
      throw new Error(`Failed to update order status: ${error.message}`);
    }
  }

  /**
   * Find orders by status
   * @param {String} status - Order status
   * @param {Object} options - Query options
   * @returns {Promise<Array>} Array of orders
   */
  async findByStatus(status, options = {}) {
    try {
      const { limit = 10, skip = 0, sort = { createdAt: -1 } } = options;
      
      return await this.Order
        .find({ status })
        .sort(sort)
        .limit(limit)
        .skip(skip);
    } catch (error) {
      throw new Error(`Failed to find orders by status: ${error.message}`);
    }
  }

  /**
   * Get order statistics
   * @param {String} customerId - Optional customer ID filter
   * @returns {Promise<Object>} Order statistics
   */
  async getStats(customerId = null) {
    try {
      const match = customerId ? { customerId } : {};
      
      const stats = await this.Order.aggregate([
        { $match: match },
        {
          $group: {
            _id: null,
            totalOrders: { $sum: 1 },
            totalRevenue: { $sum: '$totalAmount' },
            averageOrderValue: { $avg: '$totalAmount' },
            statusBreakdown: {
              $push: '$status'
            }
          }
        }
      ]);

      return stats[0] || {
        totalOrders: 0,
        totalRevenue: 0,
        averageOrderValue: 0,
        statusBreakdown: []
      };
    } catch (error) {
      throw new Error(`Failed to get order statistics: ${error.message}`);
    }
  }

  /**
   * Delete order (soft delete by updating status)
   * @param {String} orderId - Order ID
   * @returns {Promise<Object|null>} Updated order
   */
  async softDelete(orderId) {
    try {
      const order = await this.Order.findOne({ orderId });
      
      if (!order) {
        return null;
      }

      if (!order.canBeCancelled()) {
        throw new Error('Order cannot be cancelled in current status');
      }

      order.status = 'cancelled';
      return await order.save();
    } catch (error) {
      throw new Error(`Failed to cancel order: ${error.message}`);
    }
  }
}

module.exports = OrderRepository;